package git

import (
	"bufio"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// GeneratedFileDetector provides methods to detect generated files
// Ported from github-linguist/linguist/lib/linguist/generated.rb
type GeneratedFileDetector struct {
	// Compiled regex patterns
	vendorPathRegex            *regexp.Regexp
	documentationPathRegex     *regexp.Regexp
	npmPathRegex               *regexp.Regexp
	cocoapodsPathRegex         *regexp.Regexp
	xcodePathRegex             *regexp.Regexp
	objectiveCPathRegex        *regexp.Regexp
	swiftPackagePathRegex      *regexp.Regexp
	ideaPathRegex              *regexp.Regexp
	sphinxRegex                *regexp.Regexp
	yarnLockRegex              *regexp.Regexp
	terraformLockRegex         *regexp.Regexp
	denoLockRegex              *regexp.Regexp
	relayGeneratedRegex        *regexp.Regexp
	androidGeneratedRegex      *regexp.Regexp
	unityPathRegex             *regexp.Regexp
	unityMetaPathRegex         *regexp.Regexp
	minifiedJSRegex            *regexp.Regexp
	sourcemapRegex             *regexp.Regexp
	goGeneratedHeaderRegex     *regexp.Regexp
	rustGeneratedHeaderRegex   *regexp.Regexp
	pbGeneratedHeaderRegex     *regexp.Regexp
	cythonGeneratedHeaderRegex *regexp.Regexp
	grpcGeneratedHeaderRegex   *regexp.Regexp
	dartGeneratedHeaderRegex   *regexp.Regexp
	haxeGeneratedHeaderRegex   *regexp.Regexp
}

// NewGeneratedFileDetector creates a new instance of the generated file detector
func NewGeneratedFileDetector() *GeneratedFileDetector {
	detector := &GeneratedFileDetector{
		// Vendor paths
		vendorPathRegex: regexp.MustCompile(`(?:^|\/)(?:vendor|third_party|deps|node_modules)\/`),

		// Documentation paths
		documentationPathRegex: regexp.MustCompile(`(?:^|\/)(?:docs?|[^\/]*[dD]ocumentation)\/`),

		// npm dependencies
		npmPathRegex: regexp.MustCompile(`node_modules\/`),

		// CocoaPods
		cocoapodsPathRegex: regexp.MustCompile(`(?:^|\/)Pods\/`),

		// Xcode
		xcodePathRegex: regexp.MustCompile(`\.(?:xcdatamodeld|xcmappingmodel|xcassets|xcodeproj|xcworkspace)\/`),

		// Objective-C and Swift dependencies
		objectiveCPathRegex:   regexp.MustCompile(`\.framework\/`),
		swiftPackagePathRegex: regexp.MustCompile(`\.swiftpm\/`),

		// IntelliJ IDEA
		ideaPathRegex: regexp.MustCompile(`(?:^|\/)\.idea\/`),

		// Sphinx
		sphinxRegex: regexp.MustCompile(`\.egg-info\/`),

		// Yarn, Terraform and Deno locks
		yarnLockRegex:      regexp.MustCompile(`(?:^|\/)yarn\.lock$`),
		terraformLockRegex: regexp.MustCompile(`(?:^|\/)\.terraform\.lock\.hcl$`),
		denoLockRegex:      regexp.MustCompile(`(?:^|\/)deno\.lock$`),

		// Relay GraphQL generated files
		relayGeneratedRegex: regexp.MustCompile(`__generated__\/`),

		// Android generated files
		androidGeneratedRegex: regexp.MustCompile(`(?:^|\/)(?:AndroidManifest\.xml|R\.java|BuildConfig\.java|[^\/]*Fragment\.java|[^\/]*Activity\.java)$`),

		// Unity generated files
		unityPathRegex:     regexp.MustCompile(`(?:^|\/)Unity[\/\\]`),
		unityMetaPathRegex: regexp.MustCompile(`\.meta$`),

		// Minified JavaScript
		minifiedJSRegex: regexp.MustCompile(`(?:\.min)\.(?:js|css)$`),
		sourcemapRegex:  regexp.MustCompile(`\.(?:js|css)\.map$`),

		// Generated code headers
		goGeneratedHeaderRegex:     regexp.MustCompile(`(?i)^// Code generated .* DO NOT EDIT\.?$`),
		rustGeneratedHeaderRegex:   regexp.MustCompile(`(?i)^// Generated file, do not edit by hand`),
		pbGeneratedHeaderRegex:     regexp.MustCompile(`(?i)^// Generated by the protocol buffer compiler`),
		cythonGeneratedHeaderRegex: regexp.MustCompile(`(?i)^# Generated by Cython`),
		grpcGeneratedHeaderRegex:   regexp.MustCompile(`(?i)^// Generated by the gRPC`),
		dartGeneratedHeaderRegex:   regexp.MustCompile(`(?i)^// GENERATED CODE - DO NOT MODIFY BY HAND`),
		haxeGeneratedHeaderRegex:   regexp.MustCompile(`(?i)^\s*\/\/ Generated by Haxe`),
	}
	return detector
}

// IsGenerated checks if a file is likely generated based on its path and content
func (d *GeneratedFileDetector) IsGenerated(filePath string) bool {
	// Extract filename, extension, and name components
	filename := filepath.Base(filePath)
	ext := strings.ToLower(filepath.Ext(filePath))
	name := filePath

	// Direct check for common generated file patterns
	lowerName := strings.ToLower(name)
	if strings.Contains(lowerName, ".pb.go") ||
		strings.Contains(lowerName, ".pb.cc") ||
		strings.Contains(lowerName, ".pb.h") ||
		strings.Contains(lowerName, ".g.cs") ||
		strings.Contains(lowerName, ".g.h") ||
		strings.Contains(lowerName, ".g.java") ||
		strings.Contains(lowerName, ".g.dart") ||
		strings.Contains(lowerName, ".g.m") ||
		strings.Contains(lowerName, ".g.swift") ||
		strings.Contains(lowerName, ".gen.go") ||
		strings.Contains(lowerName, ".gen.cs") ||
		strings.Contains(lowerName, ".gen.js") ||
		strings.Contains(lowerName, ".gen.ts") ||
		strings.Contains(lowerName, ".generated.") ||
		strings.Contains(lowerName, ".d.ts") {
		return true
	}

	// Check path-based patterns
	if d.vendorPathRegex.MatchString(name) {
		return true
	}

	if d.documentationPathRegex.MatchString(name) {
		return true
	}

	if d.npmPathRegex.MatchString(name) {
		return true
	}

	if d.cocoapodsPathRegex.MatchString(name) {
		return true
	}

	if d.xcodePathRegex.MatchString(name) {
		return true
	}

	if d.objectiveCPathRegex.MatchString(name) {
		return true
	}

	if d.swiftPackagePathRegex.MatchString(name) {
		return true
	}

	if d.ideaPathRegex.MatchString(name) {
		return true
	}

	if d.sphinxRegex.MatchString(name) {
		return true
	}

	if d.relayGeneratedRegex.MatchString(name) {
		return true
	}

	if d.unityPathRegex.MatchString(name) {
		return true
	}

	// Check filename-based patterns
	if d.yarnLockRegex.MatchString(name) || d.terraformLockRegex.MatchString(name) || d.denoLockRegex.MatchString(name) {
		return true
	}

	if d.minifiedJSRegex.MatchString(name) || d.sourcemapRegex.MatchString(name) {
		return true
	}

	if d.unityMetaPathRegex.MatchString(name) {
		return true
	}

	if d.androidGeneratedRegex.MatchString(name) {
		return true
	}

	// Check specific extensions that indicate generated files
	if isGeneratedExtension(ext) {
		return true
	}

	// Check lock files
	if isLockFile(filename) {
		return true
	}

	// Check for known generated file patterns
	if isGeneratedFilename(filename) {
		return true
	}

	// If the file exists, scan the content for generated markers
	if d.hasGeneratedContent(filePath) {
		return true
	}

	// If the file is minified (very long lines)
	if d.isMinified(filePath) {
		return true
	}

	return false
}

// isGeneratedExtension checks if a file extension indicates a generated file
func isGeneratedExtension(ext string) bool {
	// Handle files with compound extensions like .pb.go
	filename := filepath.Base("test" + ext) // Add dummy prefix to ensure it's treated as a filename
	lowerFilename := strings.ToLower(filename)

	// Special compound extensions
	compoundExtensions := []string{
		".pb.go", ".pb.cc", ".pb.h",
		".g.cs", ".g.h", ".g.java", ".g.dart", ".g.m", ".g.swift",
		".gen.go", ".gen.cs", ".gen.js", ".gen.ts",
		".generated.cs", ".generated.h",
		".pbobjc.h", ".pbobjc.m",
	}

	for _, cmpExt := range compoundExtensions {
		if strings.HasSuffix(lowerFilename, cmpExt) {
			return true
		}
	}

	// Simple extensions
	simpleExtensions := []string{
		".meta", ".nib", ".xcworkspacedata", ".xcuserstate", ".moc",
		".obj", ".rbi", ".ipp", ".d.ts", ".timestamp", ".proto.h",
	}

	for _, simpleExt := range simpleExtensions {
		if strings.EqualFold(ext, simpleExt) {
			return true
		}
	}

	return false
}

// isLockFile checks if a file is a dependency lock file
func isLockFile(filename string) bool {
	lockFiles := []string{
		"yarn.lock", "package-lock.json", "composer.lock",
		"cargo.lock", "poetry.lock", "Gopkg.lock", "go.sum",
		"Gemfile.lock", "packages.lock.json", ".terraform.lock.hcl",
		"deno.lock", "pnpm-lock.yaml", "flake.lock",
	}

	for _, lockFile := range lockFiles {
		if strings.EqualFold(filename, lockFile) {
			return true
		}
	}

	return false
}

// isGeneratedFilename checks if a filename indicates a generated file
func isGeneratedFilename(filename string) bool {
	generatedPatterns := []string{
		".min.js", ".min.css", "-min.js", "-min.css",
		".bundle.js", ".bundle.css", ".pack.js",
		"jquery-", "jquery.", "Chart.js", "d3.js", "react.js",
		"angular.js", "bootstrap.css", "normalize.css",
		"semantic.css", "semantic.js", "semantic-ui", "dist.js",
		"gl-matrix", "kotlin-dce", "webpack-runtime",
	}

	for _, pattern := range generatedPatterns {
		if strings.Contains(filename, pattern) {
			return true
		}
	}

	// Check for common generated suffixes
	generatedSuffixes := []string{
		".generated.", ".auto.", ".designer.",
		".dist.", ".bundle.", ".vendor.", ".compiled.",
	}

	for _, suffix := range generatedSuffixes {
		if strings.Contains(filename, suffix) {
			return true
		}
	}

	return false
}

// hasGeneratedContent checks if file content indicates it's generated
func (d *GeneratedFileDetector) hasGeneratedContent(filePath string) bool {
	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	// Scan the first 40 lines of the file to check for generated markers
	scanner := bufio.NewScanner(file)
	lineCount := 0
	maxLines := 40

	for scanner.Scan() && lineCount < maxLines {
		line := scanner.Text()

		// Check for various generated code headers
		if d.goGeneratedHeaderRegex.MatchString(line) ||
			d.rustGeneratedHeaderRegex.MatchString(line) ||
			d.pbGeneratedHeaderRegex.MatchString(line) ||
			d.cythonGeneratedHeaderRegex.MatchString(line) ||
			d.grpcGeneratedHeaderRegex.MatchString(line) ||
			d.dartGeneratedHeaderRegex.MatchString(line) ||
			d.haxeGeneratedHeaderRegex.MatchString(line) {
			return true
		}

		// Check for generic "generated" markers
		if strings.Contains(strings.ToLower(line), "generated code") ||
			strings.Contains(strings.ToLower(line), "autogenerated") ||
			strings.Contains(strings.ToLower(line), "auto-generated") ||
			strings.Contains(strings.ToLower(line), "automatically generated") ||
			strings.Contains(strings.ToLower(line), "machine generated") ||
			strings.Contains(strings.ToLower(line), "this code was generated") ||
			strings.Contains(strings.ToLower(line), "code generated by") ||
			strings.Contains(strings.ToLower(line), "@generated") {
			return true
		}

		lineCount++
	}

	return false
}

// isMinified checks if a file is likely minified (very long lines)
func (d *GeneratedFileDetector) isMinified(filePath string) bool {
	ext := strings.ToLower(filepath.Ext(filePath))
	if ext != ".js" && ext != ".css" && ext != ".html" && ext != ".json" {
		return false
	}

	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineCount := 0
	totalLength := 0
	longLineCount := 0
	maxLines := 30

	// Configure scanner for longer line lengths
	buf := make([]byte, 0, 64*1024)
	scanner.Buffer(buf, 1024*1024)

	for scanner.Scan() && lineCount < maxLines {
		line := scanner.Text()
		lineLength := len(line)
		totalLength += lineLength

		if lineLength > 500 {
			longLineCount++
		}

		lineCount++
	}

	if err := scanner.Err(); err != nil {
		// If we can't read the whole file, it might be binary or very large,
		// which often indicates generated content
		return true
	}

	if lineCount == 0 {
		return false
	}

	// Calculate average line length
	avgLineLength := float64(totalLength) / float64(lineCount)

	// Heuristics for minified files - long average lines or many very long lines
	return avgLineLength > 110 || (longLineCount > 0 && float64(longLineCount)/float64(lineCount) > 0.3)
}

// FilterGeneratedFiles removes generated files from a list of file paths
func FilterGeneratedFiles(filePaths []string) []string {
	detector := NewGeneratedFileDetector()
	var result []string

	for _, path := range filePaths {
		if !detector.IsGenerated(path) {
			result = append(result, path)
		}
	}

	return result
}

// FilterGeneratedDiff filters out changes to generated files from a git diff
func FilterGeneratedDiff(diff string) string {
	if diff == "" {
		return ""
	}

	// Split the diff into files
	diffFiles := strings.Split(diff, "diff --git ")
	if len(diffFiles) <= 1 {
		return diff
	}

	detector := NewGeneratedFileDetector()
	var filteredDiff strings.Builder

	// The first element is empty or header info
	if diffFiles[0] != "" {
		filteredDiff.WriteString(diffFiles[0])
	}

	// Process each file diff
	for i := 1; i < len(diffFiles); i++ {
		fileDiff := diffFiles[i]
		// Extract the file path - typically in the format "a/path/file.ext b/path/file.ext"
		pathLine := strings.Split(fileDiff, "\n")[0]
		filePath := ""

		// Extract the file path after "a/"
		parts := strings.Fields(pathLine)
		if len(parts) >= 1 {
			// Get path after "a/"
			filePath = strings.TrimPrefix(parts[0], "a/")
		}

		// If we couldn't parse the path or it's not a generated file, include it
		if filePath == "" || !detector.IsGenerated(filePath) {
			filteredDiff.WriteString("diff --git ")
			filteredDiff.WriteString(fileDiff)
		}
	}

	return filteredDiff.String()
}

// GetStagedDiffFiltered returns the diff of staged changes, filtering out generated files
func GetStagedDiffFiltered() string {
	diff := GetStagedDiff()
	return FilterGeneratedDiff(diff)
}
